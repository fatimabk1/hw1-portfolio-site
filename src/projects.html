<!DOCTYPE html>
<html lang="en">
<head>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="script.js"></script>
    <link href="output.css" rel="stylesheet">
    <title>Projects</title>
</head>
<body class="mx-auto max-w-2xl bg-blue-300 text-gray-800 font-sans leading-relaxed p-6 my-4">
    <header class="text-center py-8">
        <h1 class="text-5xl font-bold max-w-screen-md mx-auto text-white mx-10 ColorMe">Featured Project</h1>
    </header>

    <section class="mb-12">
        <h2 class="item-title text-2xl text-white mb-4">MemoNest: A Nested Voice Memo App for iOS</h2>
        <p class="item-description mb-4">
            Voice recording software is widely used for various purposes such as personal diaries, lectures, and more. Despite the variety of features available in existing apps, many lack a simple but essential feature: nested organization. Most apps either lack organization tools, requiring users to manually search through a long list, or only offer a single level of folders.
        </p>
        <p class="item-description mb-4">
            MemoNest aims to improve user experience by enabling nested organization. Users can create groups and sub-groups for recordings, enhancing their ability to organize and retrieve audio files. The project's scope includes the following features:
        </p>
        
        <ul class="list-inside list-disc mb-4">
            <li>Creating recordings (start, stop, automatic save to local database)</li>
            <li>Playing recordings (play, pause, seek)</li>
            <li>Managing audio (delete, rename)</li>
            <li>Organizing recordings (create folders, rename folders, sort items, move recordings/folders)</li>
        </ul>

        <p>
            <strong>Key Technologies:</strong> Swift, SwiftUI, Realm, XCTest, AVAudioPlayer, and AVAudioRecorder.
        </p>
    </section>

    <!-- Key Design Decisions Section -->
    <section>
        <h2 class="text-4xl text-left text-white mb-6">Key Design Decisions</h2>

        <div class="mt-6">
            <h3 class="item-title">Separate Services for Recording and Playback</h3>
            <p class="item-description mt-2">
                I designed a streamlined single-page interface for recording and playback, with separate services for each. The main view model manages the <i>RecordingService</i> and <i>PlaybackService</i>, using Combine for state updates to ensure the UI reflects changes in real-time. This modularity allows for future reuse, and Combine simplifies state management.
            </p>
        </div>

        <div class="mt-6">
            <h3 class="item-title">Single Page UI for Navigation</h3>
            <p class="item-description mt-2">
                To avoid stack overflow issues, the app uses a single-page UI to display nested folders. This approach enhances performance, prevents large stack growth, and simplifies navigation flow, even for deep folder structures.
            </p>
        </div>

        <div class="mt-6">
            <h3 class="item-title">Dependency Injection with DataManager Protocol</h3>
            <p class="item-description mt-2">
                To facilitate switching between production and test databases, I implemented dependency injection with a <i>DataManager</i> protocol. This allows for easy swapping of database implementations, making the app more testable and reducing the complexity of changes.
            </p>
        </div>

        <div class="mt-6">
            <h3 class="item-title">Data Mapper Pattern for Object-Database Separation</h3>
            <p class="item-description mt-2">
                To ensure clear separation between domain logic and database representation, I used the Data Mapper Pattern. This abstraction layer makes the database mapping logic flexible and isolated, making future database changes or migrations easier and less disruptive.
            </p>
        </div>

        <div class="mt-6">
            <h3 class="item-title">BFS Folder Deletion with Combine</h3>
            <p class="item-description mt-2">
                For efficient and safe folder deletion, I used a BFS approach with Combine. By storing parent folder IDs instead of references, the app avoids data integrity issues when deleting folders or items, while improving performance for folder deletion and item display operations.
            </p>
        </div>

        <div class="mt-6">
            <h3 class="item-title">Unified Item Protocol for Files and Folders</h3>
            <p class="item-description mt-2">
                To display both files and folders uniformly, I created an <i>Item</i> protocol that both file and folder objects conform to. This simplified the UI code and allowed for interchangeable handling of files and folders, implementing the Composite Pattern.
            </p>
        </div>
    </section>

</body>
</html>
